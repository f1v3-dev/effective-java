# 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

Java 8 이후 `default method`를 통해 인터페이스에서도 메서드를 구현할 수 있게 되었다. 이는 기존의 인터페이스를 구현한 클래스들에게 새로운 메서드를 제공할 수 있게 되었지만, 이로 인해 새로운
문제가
발생한다.

- 기존 구현체들과 매끄럽게 연동되지 않을 수 있다.
    - Java 7 까지는 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다고 생각했기 때문이다.
- **default method** 는 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 '삽입'될 뿐이다.

> 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어렵다.

## Default Method 주의사항

- Java 8의 Collection 인터페이스에 추가된 `removeIf` 메서드를 살펴보자

_removeIf method_

```java
import java.util.Iterator;
import java.util.Objects;

default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean result = false;

    for (Iterator<E> it = iterator(); it.hasNext(); ) {
        if (filter.test(it.next())) {
            it.remove();
            result = true;
        }
    }

    return result;
}
```

이 코드보다 더 범용적으로 구현하기도 어렵겠지만, 모든 Collection 구현체와 잘 어우러지는 것은 아니다.

- `org.apache.commons.collections4.collections.SynchronizedCollection` 이 대표적이다.
    - 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 위임하는 래퍼 클래스
- 책을 쓴 시점에서는 `removeIf` 메서드를 재정의하고 있지 않아, 디폴트 구현을 그대로 사용하여 락 객체로 동기화할 수 없는 문제가 발생한다.
- 이러한 결과, `ConcurrentModificationException` 이 발생하거나 예기치 못한 결과로 이어질 수 있다.

### Java 플랫폼 라이브러리에서의 조치

- 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전 필요한 작업을 수행하도록 했다.
- Java 플랫폼에 속하지 않은 컬렉션 구현체들은 이러한 방식을 따르지 않을 수 있어 주의해야 한다.

## 인터페이스 설계 시 주의사항

#### `default method` 로 새 메서드를 추가하는 일은 정말 필요한 경우가 아니면 피하자.

- 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지는 않을지 심사숙고 해야하는 것도 당연하다.
- 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는데 아주 유용한 수단이며 더 쉽게 구현해 활용할 수 있게끔 해주는 장점이 있다.

심각하게 잘못된 인터페이스라면 어떤 큰 문제를 불러일으킬지 알 수 없다.

#### 새로운 인터페이스라면 릴리스 전에 테스트를 진행하자.

- 수 많은 개발자가 그 인터페이스를 나름의 방식으로 구현할 것이다.
- 서로 다른 방식으로 세 가지는 구현해보자.
- 더 나아가 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 만들어보자

> 이렇게 새로운 인터페이스를 만드는 것은 쉬운 일이 아니다. 인터페이스를 릴리스한 후에 결함을 수정하는게 가능한 경우도 있겠지만, 절대 그 가능성에 기대해서는 안된다.  
> **즉, 신중하게 설계하고 테스트한 후에 릴리스해야 한다.**